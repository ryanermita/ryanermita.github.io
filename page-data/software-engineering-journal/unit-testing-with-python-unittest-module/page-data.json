{"componentChunkName":"component---src-templates-blog-post-js","path":"/software-engineering-journal/unit-testing-with-python-unittest-module","result":{"data":{"markdownRemark":{"html":"<p>A well-designed software is build and designed with quality in mind and it doesn’t easily break with small code changes. We can ensure that our code still works regardless of code changes if we’re doing tests. That’s why doing tests is very important part of building a well-designed application because it ensures quality. This statement below by <a href=\"https://jacobian.org/\">Jacob Kaplan-Moss</a>, a <a href=\"https://www.djangoproject.com/\">django</a> core developer, says it all.</p>\n<blockquote>\n<p>Code without tests is broken by design. - Jacob Kaplan-Moss</p>\n</blockquote>\n<p>So what is unit test, Unit Testing is a process of testing small pieces or unit of your code, making sure it works as expected in a positive and negative scenarios. Our mindset during unit testing should be on that small piece of code we’re testing and not with the whole application. In Python, there are a lot of libraries you can use to do unit test: <a href=\"https://docs.pytest.org/en/latest/\">pytest</a>, <a href=\"https://nose.readthedocs.io/en/latest/testing.html\">nose</a>, <a href=\"https://docs.python.org/3.5/library/unittest.html\">unittest</a> among others. In this article we will focus on using unittest with python version 3.5.2.</p>\n<h2>Why Write Unit Tests?</h2>\n<ul>\n<li>It saves us a lot of time</li>\n</ul>\n<p>Doing manual testing takes a lot of time and effort, imagine we need to test every positive and negative scenarios every time we did an update on our codebase, the larger the code base, the larger the effort and time we put on manual testing and there’s a big possibility that we’ll missed a lot of scenarios. By writing unit tests, we can easily automate our tests and rerun it every time we update our code. Running automated tests would take a minute or two compared with manual testing that could take more than 15 minutes. Unit Test formalize the test approach in a way it saves time and effort.</p>\n<ul>\n<li>Increase Code Quality</li>\n</ul>\n<p>Developing new features, fixing bugs, or code refactoring might introduce new bugs or breaks our code in any way. Unit test prevent or lessen the chance of that from happening. By running our unit tests every time we did an update in our codebase we can validate if those updates breaks any existing feature(s) in our application. Also, writing tests forces us to think about the non-normal conditions or edges cases our code might encounter and prevent them as soon as possible.</p>\n<ul>\n<li>Helps us to have a Good System Design</li>\n</ul>\n<p>As stated above, Unit Testing is a process of testing small pieces or unit of our code. That’s why unit test should be small, if you realized that you’re writing a large amount of code for unit test just for a single function, you need to refactor that function to make it small, modular, and loosely coupled. A modular and loosely coupled application is a well-designed application.</p>\n<ul>\n<li>Unit Tests also serves as a documentation</li>\n</ul>\n<p>As a new member of a team, looking at the unit tests of the codebase is a great help for understanding the project. Unit Tests shows what would be the behavior of the functions/modules in a specific scenario. This serves as the business-rule documentation inside our codebase.</p>\n<h2>Python unittest module walk-through</h2>\n<p>We’ll use this simple test script below to demonstrate how to write and run unit tests using python unittest module.</p>\n<pre><code># test_foo.py\nimport unittest\n\n# function to be tested\ndef add(a, b):\n    return a + b\n\nclass FooTestCase(unittest.TestCase):    \n    \n    # test method       \n    def test_add(self):\n        sum = add(1, 2) \n        \n        # validate the result of the code we're testing.\n        self.assertEqual(3, sum)    \n    \n    def test_add_negative_numbers(self):\n        sum = add(-1-2)\n        self.assertEqual(-3, sum)\n</code></pre>\n<p> </p>\n<h3>To write a test script using python unittest module:</h3>\n<ul>\n<li>Create an empty python file with the filename prefixed by <code>test_</code> . This way we can easily distinguish that a file is a test script.</li>\n<li>We start by importing the unittest module, we don't need to install anything as it is part of python standard library.</li>\n<li>We write our testcases. Writing testcases using unittest module follows the object oriented programming paradigm. Our testcase is a class which extends from <code>unittest.TestCase</code>. TestCase from unittest module has the methods and attributes we need in running and validating our code.</li>\n<li>We create test methods to validate different scenarios in our code. We use <a href=\"https://docs.python.org/3.5/library/unittest.html#unittest.TestCase.debug\"><code>assert* methods</code></a> from <code>unittest.TestCase</code> to validate our code based on our expected output and the result of the code we’re testing, as with the example above we’re validating if the <code>add()</code> function return value is equal with our expected value. When writing test methods its a best practice to make the method name as descriptive as possible, its a good idea to use sentence-like format when naming test methods as this will show in the report after running all our tests. Also don't forget to prefix your test method with <code>test_</code> so unittest will know that they will be run, evaluated, and include in test reporting.</li>\n</ul>\n<h3>To run test scripts written via unittest module:</h3>\n<pre><code>python -m unittest test_foo -v\n</code></pre>\n<p>which will result into this:</p>\n<pre><code>test_add (test_foo.TestFoo) ... ok\ntest_add_negative_numbers (test_foo.TestFoo) ... ok\n\n------------------------------------------------------------------\nRan 2 tests in 0.000s\nOK\n</code></pre>\n<p>The test result is very easy to understand, It shows the total test count and the test methods that is included in our test script. And when we encounter an error or failure in our test, it gives helpful information to fix the issue. for example:</p>\n<pre><code>test_add (test_foo.TestFoo) ... FAIL\ntest_add_negative_numbers (test_foo.TestFoo) ... ok\n\n==================================================================\nFAIL: test_add (test_foo.TestFoo)\n------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/home/ryan/Workspace/playground/python-unittest/test_foo.py\", line 13, in test_add\n    self.assertEqual(4, sum)\nAssertionError: 4 != 3\n\n------------------------------------------------------------------\nRan 2 tests in 0.000s\nFAILED (failures=1)\n</code></pre>\n<p>There are many ways to run a unittest script which is flexible enough to meet our needs. I include the <code>-v</code> option to have a verbose output.</p>\n<pre><code># discover and run all test scripts \n# from current package and its sub package.\npython -m unittest discover -v\n\n# equivalent with the command above.\npython -m unittest -v\n\n# discover and run all test scripts \n# from specified package and its sub modules.\npython -m unittest &#x3C;package> -v\n\n# run specific test script\npython -m test_script -v# run specific test class inside a test script\npython -m unittest test_module.TestClass -v\n\n# run specific test method of a test class of a test module\npython -m unittest test_module.TestClass.test_method -v\n</code></pre>\n<p>Also, we can make our test script executable. By doing so, we can remove <code>-m unittest</code> and run the test script as normal python script. But there’s a caveat, we can only run the test script as a whole and not by testcase class or by test methods.</p>\n<pre><code>if __name__ == '__main__':\n    unittest.main()\n</code></pre>\n<p>Including the code block above at the bottom of our test script, we can now run our test script using this command.</p>\n<pre><code>python test_foo.py -v\n</code></pre>\n<p>We can skip a test method in our testcase using <code>@unittest.skip(\"your reason\")</code></p>\n<pre><code>@unittest.skip(\"skipping test because i like it.\")\ndef test_add_negative_numbers(self):\n        sum = add(-1,-2)                                \n        self.assertEqual(-3, sum)\n</code></pre>\n<p>This will give us this result:</p>\n<pre><code>test_add (test_foo.TestFoo) ... ok\ntest_add_negative_numbers (test_foo.TestFoo) ... skipped 'skipping test because i like it.'\n\n------------------------------------------------------------------\nRan 2 tests in 0.000sOK (skipped=1)\n</code></pre>\n<p> </p>\n<h3>Test setup and cleanup</h3>\n<p>Most of the time we need to run a code before and after a test method. For example, before running our test method we need to setup the database connection, initialize our classes, prepare our test data, etc. Also after we run our test method, we need to close our database connection and clear any traces of our tests. These actions are called <strong>test fixtures</strong>.</p>\n<p>In python unittest module, this test fixtures are possible by overriding these methods in our testcase class:</p>\n<ul>\n<li><code>setUp()</code> — runs before every test method.</li>\n<li><code>tearDown()</code> — runs after every test method.</li>\n<li><code>setUpClass()</code> — runs before all the test methods. This is decorated by <code>@classmethod</code></li>\n<li><code>tearDownClass()</code> — runs after all the test methods. This is decorated by <code>@classmethod</code></li>\n</ul>\n<pre><code># test_foo.py\nimport unittestdef add(a, b):\n    return a + bclass TestFoo(unittest.TestCase):    \n    \n    @classmethod\n    def setUpClass(self):\n        print(\"this will run before all test methods.\")    \n        \n    @classmethod    \n    def tearDownClass(self):    \n        print(\"this will run after all test methods.\")   \n \n    def setUp(self):\n        print(\"this will run before every test method.\")    \n        \n    def tearDown(self):    \n        print(\"this will run after every test method.\")   \n        \n    def test_add(self):\n        sum = add(1, 2)\n        print(\"I am test_add()\")\n        self.assertEqual(3, sum)\n \n    def test_add_negative_numbers(self):\n        sum = add(-1, -2)\n        print(\"I am test_add_negative_numbers()\")\n        self.assertEqual(-3, sum)\n</code></pre>\n<p>The test script above will give us this result:</p>\n<pre><code>this will run before all test methods.\ntest_add (test_foo.TestFoo) ... this will run before every test method.\nI am test_add()\nthis will run after every test method.\nok\ntest_add_negative_numbers (test_foo.TestFoo) ... this will run before every test method.\nI am test_add_negative_numbers()\nthis will run after every test method.\nok\nthis will run after all test methods.\n\n------------------------------------------------------------------\nRan 2 tests in 0.000s\nOK\n</code></pre>\n<p> </p>\n<h3>Mocking with unittest module</h3>\n<p>There are times that the function/module which is the subject of our unit test has some dependencies that we don't have any control of, e.g external APIs or services, python standard modules, or other modules that we wrote inside our project. These dependencies might cause undesirable side effects during our test and might hinder the test itself. Good thing we can mock these dependencies and focus only on the code that we need to test.</p>\n<p>Let’s use this simple functions below to explore how to mock function/module using unittest module:</p>\n<pre><code># test_foo.py# function from third party package/module.\ndef is_legal_age(age):\n    return age >= 18# function to be tested\ndef poison():\n    if is_legal_age(18):\n        return \"Vodka\"\n    return \"Apple Juice\"\n</code></pre>\n<p>The test script below shows how we test the <code>poison()</code> function. Our <code>poison()</code> function is dependent to <code>is_legal_age()</code> function which is located from other module.</p>\n<pre><code>import unittest\nfrom unittest.mock import patchclass TestFoo(unittest.TestCase):    \n\n    @patch(\"test_foo.is_legal_age\")\n    def test_poison_for_legal_age(self,\n                                  mock_people_is_legal_age):\n        mock_people_is_legal_age.return_value = False\n        self.assertEqual(poison(), \"Apple Juice\")    \n        \n    @patch(\"test_foo.is_legal_age\")\n    def test_poison_for_illegal_age(self,\n                                    mock_people_is_legal_age):\n        mock_people_is_legal_age.return_value = True\n        self.assertEqual(poison(), \"Vodka\")\n</code></pre>\n<ul>\n<li>Import <code>patch</code> from <code>unittest.mock</code>. We’ll use this module to mock functions from other module.</li>\n<li>The simplest way to use <code>patch</code> is as a decorator. We’ll decorate our <code>test_method</code> with <code>patch</code> and use the function/module we want to mock as the decorator argument in string format. We retrieve, via dot notation, the function/module we want to mock from the module where we use them and not where they originally located.</li>\n<li>We pass the mocked function/module down to our test<em>method as a method argument, by doing so we can use the mocked function/module inside our test</em>method. Mocking function/module using unittest will replace our function/module with Mock class which has the methods and attributes we can use for mocking. With the example above, we mock the return value of our mocked function using <code>mocked_function.return_value</code>.</li>\n</ul>\n<p>With multiple <code>patch</code> decorator, order is very important. Incorrect order will raise an undesirable effects. The top most <code>patch</code> decorator will be the last mocked function/module to be pass to the test_method. for example:</p>\n<pre><code>@patch(\"module.function-nth\")\n@patch(\"module.function2\")\n@patch(\"module.function1\")\ndef test_method(self, \n                mocked_function1,\n                mocked_function2,\n                mocked_function-nth):\n    # do your test here ...\n</code></pre>\n<p>That’s it, with just three steps we’re able to mock a function from other module and continue with our unit test with ease. This is just the tip of the iceberg in regards of mocking in python unittest, I’ll create a separate post for this.</p>\n<h3>Qualities of a Good Unit Test</h3>\n<ul>\n<li>A unit test method name should be descriptive as much as possible, it can be in a sentence-like format. In this way, unit test function name is much more readable, will make sense, and would look like a business-rule documentation.</li>\n<li>Unit test should be isolated from one another, they shouldn’t rely or affect other unit tests inside the application.</li>\n<li>A unit test validate a small piece of code, it should be small and should focus only on that small piece of code.</li>\n<li>A good unit test should not leave any traces. A unit test should be responsible of cleaning its own test data and connections.</li>\n</ul>\n<h3>What’s Next?</h3>\n<p>After learning the basic usage of python unittest module, we can start adding tests in our projects and make it a habit. With what we’ve learned on this article, we can do better by exploring these topics:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Test-driven_development\">Practice Test Driven Development (TDD)</a></li>\n<li><a href=\"https://docs.python.org/3.5/library/unittest.mock.html\">Explore unittest Mock</a></li>\n<li><a href=\"https://bitbucket.org/product/features/pipelines\">Setup CI/CD</a></li>\n<li><a href=\"https://coverage.readthedocs.io/en/coverage-4.5.1a/\">Measuring your Code Unit Test Coverage</a></li>\n<li>Explore other Testing Tools: <a href=\"https://docs.pytest.org/en/latest/\">pytest</a> and <a href=\"https://nose.readthedocs.io/en/latest/testing.html\">nose</a>.</li>\n</ul>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://docs.python.org/3.5/library/unittest.html\">unittest — Unit testing framework</a></li>\n<li><a href=\"https://docs.python-guide.org/writing/tests/\">Testing Your Code</a></li>\n<li><a href=\"https://jeffknupp.com/blog/2013/12/09/improve-your-python-understanding-unit-testing/\">Improve Your Python: Understanding Unit Testing</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=6tNS--WetLI\">Python Tutorial: Unit Testing Your Code with the unittest Module</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=Sb2tz9Hlbp8&#x26;t=849s\">Andrew Knight | Testing is Fun in Python!</a></li>\n</ul>","excerpt":"A well-designed software is build and designed with quality in mind and it doesn’t easily break with small code changes. We can ensure that our code still works…","frontmatter":{"date":"September 20 , 2018","path":"/software-engineering-journal/unit-testing-with-python-unittest-module","title":"Unit Testing with Python unittest module"},"fields":{"readingTime":{"text":"11 min read"}}}},"pageContext":{}}}